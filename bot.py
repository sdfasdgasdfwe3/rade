import os
import re
import sys
import asyncio
import aiohttp
import subprocess
from telethon.sync import TelegramClient
from telethon.errors import SessionPasswordNeededError
from configparser import ConfigParser

VERSION = "1.1"
GITHUB_RAW_URL = "https://raw.githubusercontent.com/sdfasdgasdfwe3/rade/main/bot.py"
CONFIG_FILE = 'config.ini'
SESSION_FILE = 'session_name'

def parse_version(version_str):
    return tuple(map(int, version_str.split('.')))

async def check_update():
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(GITHUB_RAW_URL) as response:
                remote_code = await response.text()
                remote_version = re.search(r"VERSION\s*=\s*['\"](.*?)['\"]", remote_code).group(1)
                
                if parse_version(remote_version) > parse_version(VERSION):
                    return True, remote_code
    except Exception as e:
        print(f"–û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–π: {str(e)}")
    return False, None

async def self_update():
    print("‚ôªÔ∏è –ù–∞—á–∏–Ω–∞–µ–º –ø—Ä–æ—Ü–µ—Å—Å –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è...")
    try:
        update_available, new_code = await check_update()
        if not update_available:
            print("‚úÖ –£ –≤–∞—Å –∞–∫—Ç—É–∞–ª—å–Ω–∞—è –≤–µ—Ä—Å–∏—è –±–æ—Ç–∞")
            return

        with open(__file__, 'w', encoding='utf-8') as f:
            f.write(new_code)
            
        print("üîÑ –ë–æ—Ç —É—Å–ø–µ—à–Ω–æ –æ–±–Ω–æ–≤–ª–µ–Ω! –ü–µ—Ä–µ–∑–∞–ø—É—Å–∫–∞–µ–º...")
        os.execl(sys.executable, sys.executable, *sys.argv)
    except Exception as e:
        print(f"‚õî –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏: {str(e)}")

async def update_checker():
    while True:
        await asyncio.sleep(3600)  # –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–∞–∂–¥—ã–µ 60 –º–∏–Ω—É—Ç
        await self_update()

def create_or_read_config():
    config = ConfigParser()
    
    if not os.path.exists(CONFIG_FILE):
        print("üîß –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–æ–Ω–Ω—ã–π —Ñ–∞–π–ª –Ω–µ –Ω–∞–π–¥–µ–Ω. –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–π...")
        
        config['Telegram'] = {
            'api_id': input("–í–≤–µ–¥–∏—Ç–µ –≤–∞—à API ID: "),
            'api_hash': input("–í–≤–µ–¥–∏—Ç–µ –≤–∞—à API HASH: "),
            'phone_number': input("–í–≤–µ–¥–∏—Ç–µ –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞ (—Å –∫–æ–¥–æ–º —Å—Ç—Ä–∞–Ω—ã): ")
        }
        
        with open(CONFIG_FILE, 'w') as f:
            config.write(f)
        print(f"üíæ –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞ –≤ {CONFIG_FILE}")
    
    config.read(CONFIG_FILE)
    return config['Telegram']

# ... (–≤–µ—Å—å –ø—Ä–µ–¥—ã–¥—É—â–∏–π –∫–æ–¥ –¥–æ —Ñ—É–Ω–∫—Ü–∏–∏ main –æ—Å—Ç–∞–µ—Ç—Å—è –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π)

async def main():
    print(f"üöÄ –ó–∞–ø—É—Å–∫ –±–æ—Ç–∞ –≤–µ—Ä—Å–∏–∏ {VERSION}")
    await self_update()  # –ü—Ä–æ–≤–µ—Ä–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–π –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–µ
    
    config = create_or_read_config()
    
    client = TelegramClient(
        SESSION_FILE,
        int(config['api_id']),
        config['api_hash']
    )
    
    await client.start(phone=config['phone_number'])
    
    print("\nüîë –ê–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è –ø—Ä–æ—à–ª–∞ —É—Å–ø–µ—à–Ω–æ!")
    me = await client.get_me()
    print(f"üë§ –ò–º—è: {me.first_name}")
    print(f"üì± –ù–æ–º–µ—Ä: {me.phone}")
    
    # –ó–∞–ø—É—Å–∫ —Ñ–æ–Ω–æ–≤–æ–π –∑–∞–¥–∞—á–∏ –ø—Ä–æ–≤–µ—Ä–∫–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–π
    asyncio.create_task(update_checker())
    
    print("\nüõ†Ô∏è –î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã:")
    print("/update - –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ")
    print("/exit - –í—ã—Ö–æ–¥ –∏–∑ –±–æ—Ç–∞")
    print("/a - –í—ã–±–æ—Ä –∞–Ω–∏–º–∞—Ü–∏–∏")
    print("/p <—Ç–µ–∫—Å—Ç> - –ê–Ω–∏–º–∏—Ä–æ–≤–∞—Ç—å —Ç–µ–∫—Å—Ç\n")
    
    # –î–æ–±–∞–≤–ª—è–µ–º —Ç–æ–ª—å–∫–æ –Ω–æ–≤—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
    user_animations = {}  # {user_id: –∏–Ω–¥–µ–∫—Å –∞–Ω–∏–º–∞—Ü–∏–∏}
    user_states = {}      # {user_id: —Ç–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ}
    
    # –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ —Å–æ–±—ã—Ç–∏–π Telethon
    @client.on(events.NewMessage(pattern='/a'))
    async def animation_list_handler(event):
        user_id = event.sender_id
        response = "üé¨ –î–æ—Å—Ç—É–ø–Ω—ã–µ –∞–Ω–∏–º–∞—Ü–∏–∏:\n"
        for idx, anim in enumerate(animation_script.animations):
            response += f"{idx}. {anim['name']}\n"
        await event.respond(response + "\n–í–≤–µ–¥–∏—Ç–µ –Ω–æ–º–µ—Ä –∞–Ω–∏–º–∞—Ü–∏–∏:")
        user_states[user_id] = 'awaiting_animation_choice'

    @client.on(events.NewMessage(pattern='/p'))
    async def animate_text_handler(event):
        user_id = event.sender_id
        text = event.raw_text[3:].strip()
        
        if not text:
            await event.respond("‚ùå –£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç: /p –í–∞—à —Ç–µ–∫—Å—Ç")
            return
            
        anim_index = user_animations.get(user_id)
        if anim_index is None:
            await event.respond("‚ö†Ô∏è –°–Ω–∞—á–∞–ª–∞ –≤—ã–±–µ—Ä–∏—Ç–µ –∞–Ω–∏–º–∞—Ü–∏—é —á–µ—Ä–µ–∑ /a")
            return
            
        try:
            animation = animation_script.animations[anim_index]
            frames = animation['function'](text)
            
            for frame in frames:
                await event.respond(frame)
                await asyncio.sleep(0.3)
        except Exception as e:
            await event.respond(f"‚ö†Ô∏è –û—à–∏–±–∫–∞: {str(e)}")

    @client.on(events.NewMessage)
    async def message_handler(event):
        user_id = event.sender_id
        if user_states.get(user_id) == 'awaiting_animation_choice':
            try:
                choice = int(event.raw_text.strip())
                if 0 <= choice < len(animation_script.animations):
                    user_animations[user_id] = choice
                    selected_anim = animation_script.animations[choice]['name']
                    await event.respond(f"‚úÖ –í—ã–±—Ä–∞–Ω–æ: {selected_anim}")
                    user_states.pop(user_id, None)
                else:
                    await event.respond("‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π –Ω–æ–º–µ—Ä. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.")
            except ValueError:
                await event.respond("‚ùå –í–≤–µ–¥–∏—Ç–µ —á–∏—Å–ª–æ.")

    # –û—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–π —Ü–∏–∫–ª –≤–≤–æ–¥–∞ –∫–æ–º–∞–Ω–¥ –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –±–æ—Ç–æ–º
    while True:
        cmd = await asyncio.get_event_loop().run_in_executor(None, input, "> ")
        if cmd.strip() == '/update':
            await self_update()
        elif cmd.strip() == '/exit':
            sys.exit(0)

if __name__ == '__main__':
